/* tslint:disable */
/* eslint-disable */
/**
 * Fv1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface GetAudioUrlResp
 */
export interface GetAudioUrlResp {
  /**
   *
   * @type {string}
   * @memberof GetAudioUrlResp
   */
  url: string;
}
/**
 *
 * @export
 * @interface LoginRequestDto
 */
export interface LoginRequestDto {
  /**
   *
   * @type {string}
   * @memberof LoginRequestDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequestDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
  /**
   *
   * @type {UiUserModel}
   * @memberof LoginResponseDto
   */
  user: UiUserModel;
  /**
   *
   * @type {UserTokens}
   * @memberof LoginResponseDto
   */
  tokens: UserTokens;
}
/**
 *
 * @export
 * @interface ProgressEntity
 */
export interface ProgressEntity {
  /**
   *
   * @type {number}
   * @memberof ProgressEntity
   */
  id: number;
  /**
   *
   * @type {TeachingEntity}
   * @memberof ProgressEntity
   */
  teaching: TeachingEntity;
  /**
   *
   * @type {Array<ProgressScore>}
   * @memberof ProgressEntity
   */
  scores: Array<ProgressScore>;
  /**
   *
   * @type {number}
   * @memberof ProgressEntity
   */
  clientTimestamp: number;
}
/**
 *
 * @export
 * @interface ProgressScore
 */
export interface ProgressScore {
  /**
   *
   * @type {number}
   * @memberof ProgressScore
   */
  correctAnswersPercentage: number;
}
/**
 *
 * @export
 * @interface RefreshTokenRequestDto
 */
export interface RefreshTokenRequestDto {
  /**
   *
   * @type {string}
   * @memberof RefreshTokenRequestDto
   */
  token: string;
}
/**
 *
 * @export
 * @interface RegisterRequestDto
 */
export interface RegisterRequestDto {
  /**
   *
   * @type {string}
   * @memberof RegisterRequestDto
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof RegisterRequestDto
   */
  password: string;
}
/**
 *
 * @export
 * @interface SaveProgressReqDto
 */
export interface SaveProgressReqDto {
  /**
   *
   * @type {Array<ProgressScore>}
   * @memberof SaveProgressReqDto
   */
  scores: Array<ProgressScore>;
  /**
   *
   * @type {number}
   * @memberof SaveProgressReqDto
   */
  clientTimestamp: number;
}
/**
 *
 * @export
 * @interface StartRequestDto
 */
export interface StartRequestDto {
  /**
   *
   * @type {number}
   * @memberof StartRequestDto
   */
  teachingId: number;
}
/**
 *
 * @export
 * @interface TeachingChapter
 */
export interface TeachingChapter {
  /**
   *
   * @type {string}
   * @memberof TeachingChapter
   */
  title: string;
  /**
   *
   * @type {Array<TeachingSection>}
   * @memberof TeachingChapter
   */
  sections: Array<TeachingSection>;
  /**
   *
   * @type {Array<TeachingQuestion>}
   * @memberof TeachingChapter
   */
  questions: Array<TeachingQuestion>;
}
/**
 *
 * @export
 * @interface TeachingEntity
 */
export interface TeachingEntity {
  /**
   *
   * @type {number}
   * @memberof TeachingEntity
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof TeachingEntity
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof TeachingEntity
   */
  subtitle: string;
  /**
   *
   * @type {Array<TeachingChapter>}
   * @memberof TeachingEntity
   */
  chapters: Array<TeachingChapter>;
}
/**
 *
 * @export
 * @interface TeachingQuestion
 */
export interface TeachingQuestion {
  /**
   *
   * @type {string}
   * @memberof TeachingQuestion
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof TeachingQuestion
   */
  question: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TeachingQuestion
   */
  options: Array<string>;
  /**
   *
   * @type {number}
   * @memberof TeachingQuestion
   */
  responseIndex: number;
}
/**
 *
 * @export
 * @interface TeachingSection
 */
export interface TeachingSection {
  /**
   *
   * @type {string}
   * @memberof TeachingSection
   */
  subtitle: string;
  /**
   *
   * @type {string}
   * @memberof TeachingSection
   */
  verses: string;
  /**
   *
   * @type {string}
   * @memberof TeachingSection
   */
  comment: string;
  /**
   *
   * @type {string}
   * @memberof TeachingSection
   */
  audioId: string;
}
/**
 *
 * @export
 * @interface UiUserModel
 */
export interface UiUserModel {
  /**
   *
   * @type {number}
   * @memberof UiUserModel
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UiUserModel
   */
  username: string;
}
/**
 *
 * @export
 * @interface UserTokens
 */
export interface UserTokens {
  /**
   *
   * @type {string}
   * @memberof UserTokens
   */
  accessToken: string;
  /**
   *
   * @type {string}
   * @memberof UserTokens
   */
  refreshToken: string;
}

/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrl: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists('getUrl', 'key', key);
      const localVarPath = `/api/audio/url/{key}`.replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUrl(
      key: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAudioUrlResp>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUrl(key, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['AudioApi.getUrl']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AudioApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrl(key: string, options?: any): AxiosPromise<GetAudioUrlResp> {
      return localVarFp.getUrl(key, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {string} key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getUrl(key: string, options?: RawAxiosRequestConfig) {
    return AudioApiFp(this.configuration)
      .getUrl(key, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (loginRequestDto: LoginRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'loginRequestDto' is not null or undefined
      assertParamExists('login', 'loginRequestDto', loginRequestDto);
      const localVarPath = `/api/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RefreshTokenRequestDto} refreshTokenRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (
      refreshTokenRequestDto: RefreshTokenRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshTokenRequestDto' is not null or undefined
      assertParamExists('refreshToken', 'refreshTokenRequestDto', refreshTokenRequestDto);
      const localVarPath = `/api/auth/refresh-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        refreshTokenRequestDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {RegisterRequestDto} registerRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: async (
      registerRequestDto: RegisterRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerRequestDto' is not null or undefined
      assertParamExists('register', 'registerRequestDto', registerRequestDto);
      const localVarPath = `/api/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(registerRequestDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGuest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/register-guest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginRequestDto: LoginRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequestDto, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['AuthApi.login']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['AuthApi.logout']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RefreshTokenRequestDto} refreshTokenRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      refreshTokenRequestDto: RefreshTokenRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTokens>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenRequestDto, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['AuthApi.refreshToken']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {RegisterRequestDto} registerRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async register(
      registerRequestDto: RegisterRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequestDto, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['AuthApi.register']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerGuest(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerGuest(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['AuthApi.registerGuest']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {LoginRequestDto} loginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(loginRequestDto: LoginRequestDto, options?: any): AxiosPromise<LoginResponseDto> {
      return localVarFp.login(loginRequestDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<void> {
      return localVarFp.logout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RefreshTokenRequestDto} refreshTokenRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(refreshTokenRequestDto: RefreshTokenRequestDto, options?: any): AxiosPromise<UserTokens> {
      return localVarFp.refreshToken(refreshTokenRequestDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {RegisterRequestDto} registerRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(registerRequestDto: RegisterRequestDto, options?: any): AxiosPromise<LoginResponseDto> {
      return localVarFp.register(registerRequestDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerGuest(options?: any): AxiosPromise<LoginResponseDto> {
      return localVarFp.registerGuest(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {LoginRequestDto} loginRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public login(loginRequestDto: LoginRequestDto, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .login(loginRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RefreshTokenRequestDto} refreshTokenRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refreshToken(refreshTokenRequestDto: RefreshTokenRequestDto, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .refreshToken(refreshTokenRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {RegisterRequestDto} registerRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public register(registerRequestDto: RegisterRequestDto, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .register(registerRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public registerGuest(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .registerGuest(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProgressApi - axios parameter creator
 * @export
 */
export const ProgressApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgresses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/progress`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {SaveProgressReqDto} saveProgressReqDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    save: async (
      id: number,
      saveProgressReqDto: SaveProgressReqDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('save', 'id', id);
      // verify required parameter 'saveProgressReqDto' is not null or undefined
      assertParamExists('save', 'saveProgressReqDto', saveProgressReqDto);
      const localVarPath = `/api/progress/save/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(saveProgressReqDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {StartRequestDto} startRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    start: async (startRequestDto: StartRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'startRequestDto' is not null or undefined
      assertParamExists('start', 'startRequestDto', startRequestDto);
      const localVarPath = `/api/progress/start`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(startRequestDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {SaveProgressReqDto} saveProgressReqDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sync: async (
      id: number,
      saveProgressReqDto: SaveProgressReqDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sync', 'id', id);
      // verify required parameter 'saveProgressReqDto' is not null or undefined
      assertParamExists('sync', 'saveProgressReqDto', saveProgressReqDto);
      const localVarPath = `/api/progress/sync/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(saveProgressReqDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProgressApi - functional programming interface
 * @export
 */
export const ProgressApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProgressApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProgresses(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProgressEntity>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProgresses(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ProgressApi.getProgresses']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {SaveProgressReqDto} saveProgressReqDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async save(
      id: number,
      saveProgressReqDto: SaveProgressReqDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.save(id, saveProgressReqDto, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ProgressApi.save']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {StartRequestDto} startRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async start(
      startRequestDto: StartRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressEntity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.start(startRequestDto, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ProgressApi.start']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {SaveProgressReqDto} saveProgressReqDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sync(
      id: number,
      saveProgressReqDto: SaveProgressReqDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sync(id, saveProgressReqDto, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ProgressApi.sync']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ProgressApi - factory interface
 * @export
 */
export const ProgressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ProgressApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProgresses(options?: any): AxiosPromise<Array<ProgressEntity>> {
      return localVarFp.getProgresses(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {SaveProgressReqDto} saveProgressReqDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    save(id: number, saveProgressReqDto: SaveProgressReqDto, options?: any): AxiosPromise<void> {
      return localVarFp.save(id, saveProgressReqDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {StartRequestDto} startRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    start(startRequestDto: StartRequestDto, options?: any): AxiosPromise<ProgressEntity> {
      return localVarFp.start(startRequestDto, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {number} id
     * @param {SaveProgressReqDto} saveProgressReqDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sync(id: number, saveProgressReqDto: SaveProgressReqDto, options?: any): AxiosPromise<void> {
      return localVarFp.sync(id, saveProgressReqDto, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProgressApi - object-oriented interface
 * @export
 * @class ProgressApi
 * @extends {BaseAPI}
 */
export class ProgressApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgressApi
   */
  public getProgresses(options?: RawAxiosRequestConfig) {
    return ProgressApiFp(this.configuration)
      .getProgresses(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} id
   * @param {SaveProgressReqDto} saveProgressReqDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgressApi
   */
  public save(id: number, saveProgressReqDto: SaveProgressReqDto, options?: RawAxiosRequestConfig) {
    return ProgressApiFp(this.configuration)
      .save(id, saveProgressReqDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {StartRequestDto} startRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgressApi
   */
  public start(startRequestDto: StartRequestDto, options?: RawAxiosRequestConfig) {
    return ProgressApiFp(this.configuration)
      .start(startRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {number} id
   * @param {SaveProgressReqDto} saveProgressReqDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProgressApi
   */
  public sync(id: number, saveProgressReqDto: SaveProgressReqDto, options?: RawAxiosRequestConfig) {
    return ProgressApiFp(this.configuration)
      .sync(id, saveProgressReqDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SanityCheckApi - axios parameter creator
 * @export
 */
export const SanityCheckApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sanityCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/sanity-check`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SanityCheckApi - functional programming interface
 * @export
 */
export const SanityCheckApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SanityCheckApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sanityCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sanityCheck(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SanityCheckApi.sanityCheck']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * SanityCheckApi - factory interface
 * @export
 */
export const SanityCheckApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SanityCheckApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sanityCheck(options?: any): AxiosPromise<void> {
      return localVarFp.sanityCheck(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * SanityCheckApi - object-oriented interface
 * @export
 * @class SanityCheckApi
 * @extends {BaseAPI}
 */
export class SanityCheckApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SanityCheckApi
   */
  public sanityCheck(options?: RawAxiosRequestConfig) {
    return SanityCheckApiFp(this.configuration)
      .sanityCheck(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TeachingApi - axios parameter creator
 * @export
 */
export const TeachingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNew: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/teaching/new`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TeachingApi - functional programming interface
 * @export
 */
export const TeachingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TeachingApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNew(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeachingEntity>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getNew(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['TeachingApi.getNew']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * TeachingApi - factory interface
 * @export
 */
export const TeachingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = TeachingApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNew(options?: any): AxiosPromise<Array<TeachingEntity>> {
      return localVarFp.getNew(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * TeachingApi - object-oriented interface
 * @export
 * @class TeachingApi
 * @extends {BaseAPI}
 */
export class TeachingApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TeachingApi
   */
  public getNew(options?: RawAxiosRequestConfig) {
    return TeachingApiFp(this.configuration)
      .getNew(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
